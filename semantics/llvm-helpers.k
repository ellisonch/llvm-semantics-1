// Copyright (c) 2013-2015 K Team. All Rights Reserved.
requires "llvm-syntax.k"
requires "llvm-abstractsyntax.k"
requires "llvm-settings.k"

module LLVM-HELPERS
    imports LLVM-SYNTAX
    imports LLVM-ABSTRACTSYNTAX
    imports LLVM-SETTINGS

    syntax KItem ::= "none"
    syntax KItem ::= searchElemInMap(Map,K,K) [function]

    rule searchElemInMap(.Map,.K, _:K) => none
    rule searchElemInMap(M:Map, .K, Key':K)
         => searchElemInMap(M, choice(M), Key')
         when size(M) =/=Int 0
    rule searchElemInMap(M:Map,Key:K,Key:K)
         => M[Key]
    rule searchElemInMap(M:Map,Key:K,Key':K)
         => searchElemInMap(removeAll(M,SetItem(Key)),.K,Key')
         when Key =/=K Key' andBool Key =/=K .K

    syntax Bool ::= isHexDigit(String) [function]
    rule isHexDigit(A:String) =>
          ((ordChar(A) >=Int ordChar("0"))
           andBool (ordChar(A) <=Int ordChar("9")))
             orBool ((ordChar(A) >=Int ordChar("A"))
                     andBool (ordChar(A) <=Int ordChar("F")))
         requires lengthString(A) ==Int 1
    rule isHexDigit(A:String) => false [owise]

    syntax Bool ::= isIntString(String) [function]
    rule isIntString(A) => false
         requires lengthString(A) ==Int 0
    rule isIntString(A) => true
         requires lengthString(A) ==Int 1
                  andBool ((ordChar(A) >=Int ordChar("0"))
                  andBool (ordChar(A) <=Int ordChar("9")))
    rule isIntString(A) => false
         requires lengthString(A) >=Int 1
                  andBool ((ordChar(substrString(A, 0, 1))
                                                 <Int ordChar("0"))
                  orBool (ordChar(substrString(A, 0, 1))
                                                >Int ordChar("9")))
    rule isIntString(A) => isIntString(substrString(A,
                                          1, lengthString(A)))
         requires lengthString(A) >Int 1
                  andBool ((ordChar(substrString(A, 0, 1))
                                                 >=Int ordChar("0"))
                  andBool (ordChar(substrString(A, 0, 1))
                                                <=Int ordChar("9")))


    syntax List ::= StringToList(String) [function]
    rule StringToList("") => .List
    rule
        StringToList(S:String)
            => ListItem(ordChar(substrString(S:String, 0, 1)))
                StringToList(substrString(S:String, 1, lengthString(S:String)))
        requires S =/=String "" andBool ordChar(substrString(S, 0, 1)) =/=Int 92
    rule
        StringToList(S:String)
            => ListItem(ordChar(substrString(S:String, 0, 1)))
                StringToList(substrString(S:String, 2, lengthString(S:String)))
        requires S =/=String "" andBool ordChar(substrString(S, 0, 1)) ==Int 92
             andBool lengthString(S:String) >Int 1
             andBool ordChar(substrString(S, 1, 2)) ==Int 92

    rule
        StringToList(S:String)
            => ListItem(String2Int(substrString(S, 1, 2))
                        *Int 16 +Int String2Int(substrString(S, 2, 3)))
                StringToList(substrString(S:String, 3, lengthString(S:String)))
        requires S =/=String "" andBool ordChar(substrString(S, 0, 1)) ==Int 92
             andBool lengthString(S:String) >Int 2
             andBool isHexDigit(substrString(S, 1, 2))
             andBool isHexDigit(substrString(S, 2, 3))


    // TODO many possible errors will slip by with this, but lots of stuff will work
    rule nullOfConstValueRef => loc(startMemoryLoc -Int 1, 0, undef, undef) [anywhere]

    syntax Int ::= base(Loc) [function]
    rule base(loc(Base:Int, _, _, _)) => Base:Int
    
    syntax Int ::= offset(Loc)
    rule offset(loc(_, Offset:Int, _, _)) => Offset:Int
    
    syntax Int ::= offsetLimit(Loc)
    rule offset(loc(_, _, OffsetLimit:Int, _)) => OffsetLimit
    rule offset(loc(_, _, OffsetLimit:K, _)) => -1 [owise]

    syntax Int ::= alignment(Loc)
    rule offset(loc(_, _, _, Align:Int)) => Align
    rule offset(loc(_, _, _, Align:K)) => -1 [owise]

    syntax Loc ::= Loc "+" Int [function]
    // TODO not checking for null
    
    rule loc(Base:Int, Offset:Int, Limit:K, Align:K) + Offset':Int
            => loc(Base:Int, Offset:Int +Int Offset':Int, Limit, Align)

    syntax KItem ::= splitBytes(K, K) // value, type
    syntax KItem ::= joinBytes(K, K) [strict(1)]

    syntax Int ::= wvalist(List, K)
    //rule isNat(wvalist(_, _)) => true

    syntax KItem ::= "byteType" [function]
    rule byteType => integerType(numBitsPerByte)

    syntax KItem ::= i(K) [function]//[latex "i({#1})"]
    rule i(N:Int) => integerType(N)

    syntax Int ::= sizeofInBits(K) [function]

    syntax Loc ::= intToPtrOfLoc(K, K)
    syntax Int ::= ptrToIntOfLoc(K, K)
    syntax KItem ::= read(K, K) [strict(1)]
    syntax KItem ::= write(K, K, K) [strict] // type, value, location

    syntax Kitem ::= innerType(K) [function]
    rule innerType(pointerType(K:K, _)) => K:K
    rule innerType(arrayType(K:K, _)) => K:K
    rule innerType(arrayTypeValue(K:K, _)) => K:K

    // these give the two's complement signed max and min of a type
    syntax Int ::= smax(K) [function]
    syntax Int ::= smin(K) [function]
    rule smax(Type:KResult) => (2 ^Int absInt(sizeofInBits(Type) -Int 1)) -Int 1
    rule smin(Type:KResult) => 0 -Int (2 ^Int absInt(sizeofInBits(Type) -Int 1))

    syntax Int ::= ufmax(K) [function]
    syntax Int ::= ufmin(K) [function]
    rule ufmax(Type:KResult) => (2 ^Int absInt(sizeofInBits(Type))) -Int 1
    rule ufmin(Type:KResult) => 0

    // should be a K, but builtins can't use K :(
    // declare signed : K K -> Nat // type, value
    syntax Int ::= signed(K, K) [function]
    //rule isNat(signed(_, _)) => true

    // case when in bounds
    rule signed(Type:KResult, I:Int) => I
        when smin(Type) <=Int I andBool smax(Type) >=Int I

    // this reduces it to be close
    rule signed(Type:KResult, I:Int)
            => signed(Type:KResult, I %Int (ufmax(Type) +Int 1))
        when I >Int ufmax(Type) // note umax here
    // this picks up any extra distance
    rule signed(Type:KResult, I:Int)
            => I -Int (ufmax(Type) +Int 1)
        when I >Int smax(Type) andBool I <=Int ufmax(Type)

    // same as above
    rule signed(Type:KResult, I:Int)
            => signed(Type:KResult, I %Int (ufmax(Type) +Int 1))
        when I <Int 0 -Int ufmax(Type)
    rule signed(Type:KResult, I:Int)
            => I +Int (ufmax(Type) +Int 1)
        when I <Int smin(Type) andBool I >=Int 0 -Int ufmax(Type)


    // computes the positive remainder, whereas % can returns a negative number
    // TODO maybe should go in pl builtins
    syntax Int ::= K "remInt" K [function]
    rule (I:Int remInt N:Int) => ((I %Int N) +Int N) %Int N

    // declare unsigned : K K -> Nat // type, value
    syntax Int ::= unsigned(K, K) [function]
    //rule isNat(unsigned(_, _)) => true

    rule unsigned(Type:KResult, N:Int) => N
        when ufmin(Type) <=Int N andBool ufmax(Type) >=Int N
    rule unsigned(Type:KResult, I:Int) => I remInt (ufmax(Type) +Int 1)
        when I <Int ufmin(Type)
    rule unsigned(Type:KResult, N:Int) => N %Int (ufmax(Type) +Int 1)
        when N >Int ufmax(Type)

    syntax Bool ::= isIntegerType(K) [function]
    rule isIntegerType(integerType(_)) => true
    rule isIntegerType(_) => false [owise]

    syntax Bool ::= isFloatType(K) [function]
    rule isFloatType(F:FPType) => true
    rule isFloatType(x86_mmx) => true
    rule isFloatType(_) => false [owise]

    syntax Bool ::= isPointerType(K) [function]
    rule isPointerType(pointerType(_, _)) => true
    rule isPointerType(pointerTypeValue(_, _)) => true
    rule isPointerType(_) => false [owise]

    syntax Bool ::= isArrayType(K) [function]
    rule isArrayType(arrayType(_, _)) => true
    rule isArrayType(arrayTypeValue(_, _)) => true
    rule isArrayType(_) => false [owise]

    syntax Bool ::= isStructType(K)
    rule isStructType(structType(_)) => true
    rule isStructType(structTypeValue(_)) => true
    rule isStructType(_) => false [owise]

    // fixme size should depend on architecture
    rule sizeofInBits(pointerType(_, _)) => numBytesPerPointer *Int numBitsPerByte
    rule sizeofInBits(pointerTypeValue(_, _)) => numBytesPerPointer *Int numBitsPerByte
    rule sizeofInBits(arrayType(Type:KResult, Len:Int)) => sizeofInBits(Type) *Int Len
    rule sizeofInBits(arrayTypeValue(Type:KResult, Len:Int)) => sizeofInBits(Type) *Int Len

    rule sizeofInBits(integerType(N:Int)) => N
    rule sizeofInBits(float) => 32
    rule sizeofInBits(double) => 64
    rule sizeofInBits(x86_fp80) => 80
    // TODO listK should be Fields (bug in K)
    rule sizeofInBits(structTypeValue(listK((ListItem(Type:KResult) L:List))))
      => sizeofInBits(Type) +Int sizeofInBits(structTypeValue(listK(L)))
    rule sizeofInBits(structTypeValue(listK(.List))) => 0
    rule sizeofInBits(structType(listK((ListItem(Type:KResult) L:List))))
      => sizeofInBits(Type) +Int sizeofInBits(structType(listK(L)))
    rule sizeofInBits(structType(listK(.List))) => 0

    syntax Int ::= sizeof(K) [function]
    rule sizeof(Type:KResult) => sizeofInBits(Type) /Int numBitsPerByte
        requires numBitsPerByte dividesInt sizeofInBits(Type)
    rule sizeof(Type:KResult) => sizeofInBits(Type) /Int numBitsPerByte +Int 1
        requires notBool (numBitsPerByte dividesInt sizeofInBits(Type))

    syntax KItem ::= zeroOfType(K)
    rule zeroOfType(Type:KResult) => 0
        when isIntegerType(Type)


    syntax List ::= K "copiesOf" List [function]
    rule N:Int copiesOf L:List => L (N:Int -Int 1 copiesOf L)
        when N:Int >Int 0
    rule 0 copiesOf _ => .List

    // define N:Int +Int (Offset:Int +Int sym(Base:Int))
        // => (N +Int Offset) +Int sym(Base)

    // define I:Int +Int (Offset:Int +Int sym(Base:Int))
        // => (absInt(I +Int Offset)) +Int sym(Base)
        // when I <Int 0 andBool I +Int Offset >=Int 0

    syntax SymbolicValueRef ::= makeVarFromLabel(LabelStringConstant)
                                [function]
    rule makeVarFromLabel(L:LabelStringConstant)
              => name(localVar, substrString(#tokenToString(L), 0
                    , lengthString(#tokenToString(L)) -Int 1))

    //useful function to turn a kitem into an elemList
    //here: add addNameToString to every position where it has type or valueref
    syntax KItem ::= doubleList(RetAttrs, FuncAttrs)
    syntax ElemList ::= formElemList(K) [function]

    rule formElemList(.InstructionMetadatas) => .ElemList
    rule formElemList(, Mv:MetadataVar Mi:MetadataValueInt Ins:InstructionMetadatas)
              => elemCons(val(Mv Mi),formElemList(Ins))
    rule formElemList(, Mv:MetadataVar ! { In:MetadataValues } Ins:InstructionMetadatas)
              => elemCons(val(Mv ! { In }),formElemList(Ins))
    rule formElemList(.LabelValues) => .ElemList
    rule formElemList(label Va:ValueRef, Ls:LabelValues)
                    => elemCons(val(addNameToString(Va)),formElemList(Ls))
    rule formElemList(doubleList(.RetAttrs,.FuncAttrs)) => .ElemList
    rule formElemList(doubleList(.RetAttrs,F:FuncAttr Fs:FuncAttrs))
            => elemCons(val(F),formElemList(doubleList(.RetAttrs,Fs)))
    rule formElemList(doubleList(R:RetAttr Rs:RetAttrs,Fs:FuncAttrs))
            => elemCons(val(R),formElemList(doubleList(Rs,Fs)))
    rule formElemList(.ParamList) => .ElemList
    rule formElemList(Ty:Type Pa:ParamAttrs Va:ValueRef, Pl:ParamList)
            => elemCons(val(arg(formSet(Pa),
                     addNameToString(Ty),addNameToString(Va))),formElemList(Pl))
    rule formElemList(.ParamAttrs) => .ElemList
    rule formElemList(Pa:ParamAttr Ps:ParamAttrs) => elemCons(val(Pa),formElemList(Ps))
    rule formElemList(A:Align) => val(A)
    rule formElemList(nsw) => val(nsw)
    rule formElemList(nuw) => val(nuw)
    rule formElemList(nsw nuw) => elemCons(val(nsw),elemCons(val(nuw), .ElemList))
    rule formElemList(nuw nsw) => elemCons(val(nsw),elemCons(val(nuw), .ElemList))
    rule formElemList(nwEmpty) => .ElemList
    rule formElemList(.FastMathFlags) => .ElemList
    //here | Done
    //do the same as fast for "nnan" | "ninf" | "nsz" | "arcp"
    rule formElemList(fast Fl:FastMathFlags) => elemCons(val(fast),formElemList(Fl))
    rule formElemList(nnan Fl:FastMathFlags) => elemCons(val(nnan),formElemList(Fl))
    rule formElemList(ninf Fl:FastMathFlags) => elemCons(val(ninf),formElemList(Fl))
    rule formElemList(nsz Fl:FastMathFlags) => elemCons(val(nsz),formElemList(Fl))
    rule formElemList(arcp Fl:FastMathFlags) => elemCons(val(arcp),formElemList(Fl))

    rule formElemList(inbounds) => val(inbounds)
    rule formElemList(inBoundsEmpty) => .ElemList
    rule formElemList(.IntResolveVals) => .ElemList
    rule formElemList(, It:IntType V:ValueRef Ins:IntResolveVals)
            => elemCons(val(operand(It,addNameToString(V))),formElemList(Ins))
    rule formElemList([ V1:ValueRef , V2:ValueRef ])
            => val(edge(addNameToString(V1),addNameToString(V2)))
    rule formElemList(`[_,_],_`( V1:ValueRef , V2:ValueRef , Pl:PHIList))
            => elemCons(val(edge(addNameToString(V1),addNameToString(V2))),formElemList(Pl)) 
    rule formElemList(cleanup) => val(cleanup)
    rule formElemList(cleanupEmpty) => .ElemList
    rule formElemList(.LandingpadFactors) => .ElemList
    rule formElemList(Lpf:LandingpadFactor Lpfs:LandingpadFactors)
                   => elemCons(val(Lpf),formElemList(Lpfs))
    rule formElemList(callingConvEmpty) => .ElemList
    rule formElemList(Ocv:OptCallingConv) => val(Ocv)
            when Ocv =/=K callingConvEmpty
    rule formElemList(.RetAttrs) => .ElemList
    rule formElemList(A:RetAttr As:RetAttrs) => elemCons(val(A),formElemList(As))
    rule formElemList(.FuncAttrs) => .ElemList
    rule formElemList(A:FuncAttr As:FuncAttrs) => elemCons(val(A),formElemList(As))
    rule formElemList(atomicEmpty) => .ElemList
    rule formElemList(atomic) => val(atomic)
    rule formElemList(volatileEmpty) => .ElemList
    rule formElemList(volatile) => val(volatile)
    rule formElemList(scopeorderEmpty) => .ElemList
    rule formElemList(optScopeOrder(singlethreadEmpty, Or:Ordering))
                       => val(Or)
    rule formElemList(singlethread Or:Ordering)
                       => elemCons(val(singlethread),elemCons(val(Or), .ElemList))
    rule formElemList(, Ui:UnsignedInt) => val(Ui)
    rule formElemList(Ui:UnsignedInt, Cil:ConstantIndexList)
                 => elemCons(val(Ui),formElemList(Cil))
    rule formElemList(X:Ordering) => val(X)
    rule formElemList(X:Ordering Xl:OrderingList)
                 => elemCons(val(X),formElemList(Xl))
    rule formElemList(argListUnit) => .ElemList
    rule formElemList(...) => .ElemList
    rule formElemList(Ty:Type Pa:ParamAttrs)
             => val(arg(formSet(Pa),addNameToString(Ty),.K))
    rule formElemList(argTypeThree(Ty:Type, Pa:ParamAttrs, Na:LocalVar))
             => val(arg(formSet(Pa),addNameToString(Ty)
                                                        ,addNameToString(Na)))
    rule formElemList(Ty:Type Pa:ParamAttrs, Al:ArgList)
             => elemCons(val(arg(formSet(Pa),addNameToString(Ty),.K))
	                                                                      ,formElemList(Al))
    rule formElemList(argTypeThree(Ty:Type, Pa:ParamAttrs, Na:LocalVar), Al:ArgList)
             => elemCons(val(arg(formSet(Pa),addNameToString(Ty)
                                                        ,addNameToString(Na))),formElemList(Al))
    rule formElemList(.ReturnedVal) => .ElemList
    rule formElemList(T:Type V:ValueRef , R:ReturnedVal)
                            => elemCons(val(operand(T, V)),formElemList(R))
    rule formElemList(K:K) => K [owise]


    syntax ElemList ::= formTypeCheckList(K)   [function]
    rule formTypeCheckList(.IntResolveVals) => .ElemList
    rule formTypeCheckList(, It:IntType V:ValueRef Ins:IntResolveVals)
            => elemCons(val(typeOperand(It,addNameToString(V))),formTypeCheckList(Ins))
    rule formTypeCheckList(.ParamList) => .ElemList
    rule formTypeCheckList(T:Type _:ParamAttrs V:ValueRef, Pl:ParamList)
            => elemCons(val(typeOperand(T,addNameToString(V))),formTypeCheckList(Pl))
    rule formTypeCheckList(K:K) => K [owise]


    syntax Set ::= formSet(K) [function]
    rule formSet(nwEmpty) => .Set
    rule formSet(nuw nsw) => SetItem(nuw) SetItem(nsw)
    rule formSet(nsw nuw) => SetItem(nuw) SetItem(nsw)
    rule formSet(nuw) => SetItem(nuw)
    rule formSet(nsw) => SetItem(nsw)
    rule formSet(A:NonExternalLinkage) => SetItem(A)
         requires A =/=K nonExternalLinkageEmpty
    rule formSet(nonExternalLinkageEmpty) => .Set
    rule formSet(A:GlobalType) => SetItem(A)
    rule formSet(, section S:StringName , C:Comdat , A:Align)
                                          => SetItem(section S) SetItem(C) SetItem(A)
    rule formSet(, section S:StringName , C:Comdat) => SetItem(section S) SetItem(C)
    rule formSet(, A:Align , section S:StringName) => SetItem(section S) SetItem(A)
    rule formSet(, section S:StringName , A:Align) => SetItem(section S) SetItem(A)
    rule formSet(, C:Comdat , A:Align) => SetItem(C) SetItem(A)
    rule formSet(, C:Comdat) => SetItem(C)
    rule formSet(, A:Align) => SetItem(A)
    rule formSet(, section S:StringName) => SetItem(section S)
    rule formSet(sectionComdatAndAlignEmpty) => .Set
    rule formSet(section S:StringName) => SetItem(section S)
    rule formSet(sectionEmpty) => .Set
    rule formSet(externally_initialized) => SetItem(externally_initialized)
    rule formSet(externallyInitEmpty) => .Set
    rule formSet(unnamed_addr) => SetItem(unnamed_addr)
    rule formSet(unnamedEmpty) => .Set
    rule formSet(prefix T:Type V:ValueRef) => SetItem(prefix T V)
    rule formSet(prefixEmpty) => .Set
    rule formSet(prologue T:Type V:ValueRef) => SetItem(prologue T V)
    rule formSet(prologueEmpty) => .Set
    rule formSet(E:OptAddrSpace) => SetItem(E)
         requires E =/=K addrEmpty
    rule formSet(addrEmpty) => .Set
    rule formSet(E:OptThreadLocal) => SetItem(E)
         requires E =/=K threadLocalEmpty
    rule formSet(threadLocalEmpty) => .Set
    rule formSet(E:OptDllStorageClass) => SetItem(E)
         requires E =/=K dllStorageEmpty
    rule formSet(dllStorageEmpty) => .Set
    rule formSet(E:OptVisibilityStyle) => SetItem(E)
         requires E =/=K visibilityEmpty
    rule formSet(visibilityEmpty) => .Set
    rule formSet(E:ExternalLinkage) => SetItem(E)
    rule formSet(exactEmpty) => .Set
    rule formSet(exact) => SetItem(exact)
    rule formSet(ABCinallocaOfAlloca) => SetItem(ABCinallocaOfAlloca)
    rule formSet(inallocaEmpty) => .Set
    rule formSet(atomicEmpty) => .Set
    rule formSet(atomic) => SetItem(atomic)
    rule formSet(A:Align) => SetItem(A)
    rule formSet(alignEmpty) => .Set
    rule formSet(C:Comdat) => SetItem(C)
    rule formSet(comdatEmpty) => .Set
    rule formSet(gc S:StringName) => SetItem(gc S)
    rule formSet(gcEmpty) => .Set
    rule formSet(volatileEmpty) => .Set
    rule formSet(volatile) => SetItem(volatile)
    rule formSet(scopeorderEmpty) => .Set
    rule formSet(optScopeOrder(singlethreadEmpty, S:Ordering)) => SetItem(S)
    rule formSet(singlethread S:Ordering) => SetItem(singlethread) SetItem(S)
    rule formSet(S:Ordering) => SetItem(S)
    rule formSet(S:Ordering Ss:OrderingList) => SetItem(S) formSet(Ss)
    rule formSet(.FastMathFlags) => .Set
    rule formSet(F:FastMathFlag Fl:FastMathFlags) => SetItem(F) formSet(Fl)
    rule formSet(inbounds) => SetItem(inbounds)
    rule formSet(inBoundsEmpty) => .Set
    rule formSet(cleanup) => SetItem(cleanup)
    rule formSet(cleanupEmpty) => .Set
    rule formSet(callingConvEmpty) => .Set
    rule formSet(X:OptCallingConv) => SetItem(X)
         requires X =/=K callingConvEmpty
    rule formSet(R:RetAttr Rs:RetAttrs) => SetItem(R) formSet(Rs)
    rule formSet(.RetAttrs) => .Set
    rule formSet(R:FuncAttr Rs:FuncAttrs) => SetItem(R) formSet(Rs)
    rule formSet(.FuncAttrs) => .Set
    rule formSet(R:ParamAttr Rs:ParamAttrs) => SetItem(R) formSet(Rs)
    rule formSet(.ParamAttrs) => .Set
    rule formSet(K:K) => SetItem(K) [owise]

    syntax ElemList ::= formCases(K) [function]

    rule formCases(.JumpTable) => .ElemList
    rule formCases(It:IntType Ca:ConstValueRef,
                 label Va:ValueRef Cs:JumpTable)
                 => elemCons(val(case(operand(It,addNameToString(Ca))
                                 ,addNameToString(Va))), formCases(Cs))
    rule formCases(K:K) => K [owise]

/*
    syntax ElemList ::= toCallees(ParamList) [function]

    rule toCallees(.ParamList) => .ElemList
    rule toCallees(Ty:Type Pa:ParamAttrs V:ValueRef,Pl:ParamList)
                => val(callee(operand(addNameToString(Ty)
                  ,addNameToString(V)),modifiers(formElemList(Pa)))),toCallees(Pl)
*/
    syntax KItem ::= dealWithAllocaElem(AllocMetadata) [function]

    rule dealWithAllocaElem(Ty:Type) => alloca(Ty,1,alignEmpty)
    rule dealWithAllocaElem(Ty:Type, align I:UnsignedInt)
                      => alloca(addNameToString(Ty),1,String2Int(#tokenToString(I)))
    rule dealWithAllocaElem(Ty:Type, It:IntType V:ValueRef)
                      => preAlloca(addNameToString(Ty),It
                                         ,addNameToString(V),alignEmpty)
    rule dealWithAllocaElem(Ty:Type, It:IntType V:ValueRef, align I:UnsignedInt)
                      => preAlloca(addNameToString(Ty),It,
                                   addNameToString(V),String2Int(#tokenToString(I)))

    syntax SymbolicValueRef ::= addNameToString(K) [function]

    rule addNameToString(Var:LocalName) => name(localVar, substrString(#tokenToString(Var),1
                          ,lengthString(#tokenToString(Var))))
    rule addNameToString(Var:GlobalName) => name(globalVar, substrString(#tokenToString(Var),1
                          ,lengthString(#tokenToString(Var))))
    rule addNameToString(Var:LabelStringConstant) => name(localVar, substrString(#tokenToString(Var),0
                          ,lengthString(#tokenToString(Var)) -Int 1))
    rule addNameToString(< R:ReturnedVal >) => vector(formElemList(R))
    rule addNameToString(K:K) => K [owise]

    syntax Int ::= mod(Int, Int)   [function]
    rule mod(I1:Int, I2:Int) => I1 %Int I2
        requires I1 >=Int 0
    rule mod(I1:Int, I2:Int) => I1 %Int I2 +Int I2
        requires I1 <Int 0

    syntax Bool ::= isTheInt(K)            [function]
                  | isTheBool(K)           [function]
                  | isTheLocalName(K)      [function]

    rule isTheInt(I:Int) => true
    rule isTheInt(K:K) => false [owise]
    rule isTheBool(I:Bool) => true
    rule isTheBool(K:K) => false [owise]
    rule isTheLocalName(I:LocalName) => true
    rule isTheLocalName(K:K) => false [owise]

    syntax KItem ::= getIntType(K)    [function]
                   | getIntInIntType(K) [function]
    rule getIntType(integerType(N:Int)) => integerType(N:Int)
    rule getIntType(vectorTypeValue(T:K, N:Int)) => T
    rule getIntType(K:K) => K [owise]
    rule getIntInIntType(integerType(N:Int)) => N
    rule getIntInIntType(vectorTypeValue(T:K, N:Int)) => T
    rule getIntInIntType(K:K) => K [owise]

    syntax KItem ::= normalizingInt(K, K) [function]// type, int
                   | deNormalizingInt(K, K) [function]
                   | applyInts(K, K, K, K) [function] // op, type, int, int
                   | applyInt(K, K, K, K) [function] // op, type, int, int
		   //| applyOp(K, K, K)     [function] // op, int, int 
                   | applyCast(K, K, K, K)   [function] //op, type ints, type
                   | applyCasts(K, K, K, K)   [function] //op, type ints, type

    syntax Int ::= applyOp(K, K, K)     [function] // op, int, int
    // TODO [LP]: make sure this is correct

    rule deNormalizingInt(integerType(N:Int), V:Int) => V
         requires V <Int (2 ^Int (N -Int 1))
    rule deNormalizingInt(integerType(N:Int), V:Int) => 0 -Int (V -Int (2 ^Int (N -Int 1)))
         requires V >=Int (2 ^Int (N -Int 1))
    rule deNormalizingInt(integerType(N:Int), vectorValue(elemCons(valValue(I:Int),Es:ElemList)))
                       => vectorValue(elemCons(valValue(I),
                           deNormalizingInt(integerType(N:Int), Es:ElemList)))
         requires I <Int (2 ^Int (N -Int 1))
    rule deNormalizingInt(integerType(N:Int), vectorValue(elemCons(valValue(I:Int),Es:ElemList)))
                       => vectorValue(elemCons(valValue(0 -Int (I -Int (2 ^Int (N -Int 1)))),
                           deNormalizingInt(integerType(N:Int), Es:ElemList)))
         requires I >=Int (2 ^Int (N -Int 1))
    rule deNormalizingInt(integerType(N:Int), elemCons(valValue(I:Int),Es:ElemList))
                       => elemCons(valValue(I),
                           deNormalizingInt(integerType(N:Int), Es:ElemList))
         requires I <Int (2 ^Int (N -Int 1))
    rule deNormalizingInt(integerType(N:Int), elemCons(valValue(I:Int),Es:ElemList))
                       => elemCons(valValue(0 -Int (I -Int (2 ^Int (N -Int 1)))),
                           deNormalizingInt(integerType(N:Int), Es:ElemList))
         requires I  >=Int (2 ^Int (N -Int 1))
    rule deNormalizingInt(integerType(N:Int), vectorValue(elemCons(valValue(K:K),Es:ElemList)))
                       => vectorValue(elemCons(valValue(K),
                           deNormalizingInt(integerType(N:Int), vectorValue(Es:ElemList))))
         requires notBool isTheInt(K)
    rule deNormalizingInt(integerType(N:Int), elemCons(valValue(K:K),Es:ElemList))
                       => elemCons(valValue(K),
                           deNormalizingInt(integerType(N:Int), vectorValue(Es:ElemList)))
         requires notBool isTheInt(K)
    rule deNormalizingInt(A:K, .ElemList) => .ElemList
//    rule deNormalizingInt(A:K, K:K) => K
//         requires getKLabel(K) ==KLabel 'poisonVal
//                             orBool getKLabel(K) ==KLabel 'undef
// TODO [LP]: fix this ==KLabel issue and other ==KLabel and =/=KLabel errors

    rule normalizingInt(integerType(N:Int), V:Int) => mod(V, 2 ^Int N)
    rule normalizingInt(integerType(N:Int), vectorValue(elemCons(valValue(I:Int),Es:ElemList)))
                       => vectorValue(elemCons(valValue(mod(I, 2 ^Int N)),
                           normalizingInt(integerType(N:Int), Es:ElemList)))
    rule normalizingInt(integerType(N:Int), elemCons(valValue(I:Int),Es:ElemList))
                       => elemCons(valValue(mod(I, 2 ^Int N)),
                           normalizingInt(integerType(N:Int), Es:ElemList))
    rule normalizingInt(integerType(N:Int), vectorValue(elemCons(valValue(K:K),Es:ElemList)))
                       => vectorValue(elemCons(valValue(K),
                           normalizingInt(integerType(N:Int), vectorValue(Es:ElemList))))
         requires notBool isTheInt(K)
    rule normalizingInt(integerType(N:Int), elemCons(valValue(K:K),Es:ElemList))
                       => elemCons(valValue(K),
                           normalizingInt(integerType(N:Int), vectorValue(Es:ElemList)))
         requires notBool isTheInt(K)
    rule normalizingInt(A:K, .ElemList) => .ElemList
//    rule normalizingInt(A:K, K:K) => K
//         requires getKLabel(K) ==KLabel 'poisonVal
//                             orBool getKLabel(K) ==KLabel 'undef
 
    rule applyOp(add:IntConstructors, V1:Int, V2:Int) => V1 +Int V2
    rule applyOp(sub:IntConstructors, V1:Int, V2:Int) => V1 -Int V2
    rule applyOp(mul:IntConstructors, V1:Int, V2:Int) => V1 *Int V2
    rule applyOp(shl:IntConstructors, V1:Int, V2:Int) => V1 *Int (2 ^Int V2)
    rule applyOp(or:LogicalOps, V1:Int, V2:Int) => V1 |Int V2
    rule applyOp(and:LogicalOps, V1:Int, V2:Int) => V1 &Int V2
    rule applyOp(xor:LogicalOps, V1:Int, V2:Int) => V1 xorInt V2

    rule applyInt(Op:K, integerType(N:Int), V1:Int, V2:Int) => mod(applyOp(Op, V1, V2), 2 ^Int N)
    rule applyInt(Op:K, integerType(N:Int), A:K, A':K) => poisonVal
         requires A ==K poisonVal orBool A' ==K poisonVal
    rule applyInt(Op:K, integerType(N:Int), A:K, A':K) => undef
         requires (A ==K undef orBool A' ==K undef)
                   andBool A =/=K poisonVal
                   andBool A' =/=K poisonVal

    rule applyInts(Op:K, integerType(N:Int), .ElemList, .ElemList) => .ElemList
    rule applyInts(Op:K, integerType(N:Int), vectorValue(Es:ElemList)
                                       , vectorValue(Es':ElemList))
               => vectorValue(applyInts(Op, integerType(N:Int), Es, Es'))
    rule applyInts(Op:K, integerType(N:Int), elemCons(valValue(K:K),Es:ElemList)
                                       , elemCons(valValue(K':K),Es':ElemList))
               => elemCons(valValue(applyInt(Op, integerType(N:Int), K, K')),
                                       applyInts(Op, integerType(N:Int), Es, Es'))
    rule applyInts(Op:K, A:K, I1:K, I2:K) => applyInt(Op, A, I1, I2)        [owise]

    syntax Int ::= seqAdds(Int, Int) [function]
    rule seqAdds(N:Int, N':Int) => 2 ^Int N
         requires N >=Int N'
    rule seqAdds(N:Int, N':Int) => (2 ^Int N) +Int seqAdds(N +Int 1, N')
         requires N <Int N'

    rule applyCast(trunc, integerType(N:Int), V1:Int, integerType(N':Int)) => mod(V1, 2 ^Int N')
    rule applyCast(zext, integerType(N:Int), V1:Int, integerType(N':Int)) => V1
    rule applyCast(sext, integerType(N:Int), V1:Int, integerType(N':Int)) => V1
         requires V1 <Int (2 ^Int (N -Int 1))
    rule applyCast(sext, integerType(N:Int), V1:Int, integerType(N':Int)) => V1 +Int seqAdds(N, N')
         requires V1 >=Int (2 ^Int (N -Int 1))
    rule applyCast(Op:K, T:K, poisonVal, T':K) => poisonVal
    rule applyCast(Op:K, T:K, undef, T':K) => undef

    rule applyCasts(Op:K, integerType(N:Int), .ElemList, T:K) => .ElemList
    rule applyCasts(Op:K, integerType(N:Int), vectorValue(Es:ElemList), T:K)
               => vectorValue(applyCasts(Op, integerType(N:Int), Es, T:K))
    rule applyCasts(Op:K, integerType(N:Int), elemCons(valValue(K:K),Es:ElemList), T:K)
               => elemCons(valValue(applyCast(Op, integerType(N:Int), K, T)),
                                       applyCasts(Op, integerType(N:Int), Es, T))
    rule applyCasts(Op:K, A:K, I1:K, I2:K) => applyCast(Op, A, I1, I2)        [owise]


    syntax KItem ::= checkNuw(K, K)          [function]//type,  int value
                   | checkNsw(K, K, K)    [function]//type, int signed value, int value
    rule checkNuw(integerType(N:Int), V:Int) => V
         requires V <Int (2 ^Int N) andBool V >=Int 0
    rule checkNuw(integerType(N:Int), V:Int) => poisonVal
         requires V >=Int (2 ^Int N) orBool V <Int 0
//    rule checkNuw(integerType(N:Int), V:K) => V
//         requires getKLabel(V) ==KLabel 'poisonVal
//                             orBool getKLabel(V) ==KLabel 'undef
    rule checkNuw(integerType(N:Int), .ElemList) => .ElemList
    rule checkNuw(integerType(N:Int), vectorValue(Es:ElemList))
            => vectorValue(checkNuw(integerType(N:Int), Es:ElemList))
    rule checkNuw(integerType(N:Int), elemCons(valValue(K:K), Es:ElemList))
            => elemCons(valValue(K), checkNuw(integerType(N:Int),  Es:ElemList))
         requires notBool isTheInt(K)
    rule checkNuw(integerType(N:Int), elemCons(valValue(V:Int), Es:ElemList))
            => elemCons(valValue(V), checkNuw(integerType(N:Int), Es:ElemList))
         requires V <Int (2 ^Int N) andBool V >=Int 0
    rule checkNuw(integerType(N:Int), elemCons(valValue(V:Int), Es:ElemList))
            => elemCons(valValue(poisonVal), checkNuw(integerType(N:Int), Es:ElemList))
         requires V >=Int (2 ^Int N) orBool V <Int 0

    rule checkNsw(integerType(N:Int), I1:Int, V:Int) => poisonVal
         requires I1 <Int (0 -Int (2 ^Int (N -Int 1))) orBool I1 >=Int (2 ^Int (N -Int 1))
    rule checkNsw(integerType(N:Int), I1:Int, V:Int) => V
         requires I1 >=Int (0 -Int (2 ^Int (N -Int 1))) andBool I1 <Int (2 ^Int (N -Int 1))
//    rule checkNsw(integerType(N:Int), I1:K, V:K) => V
//         requires getKLabel(V) ==KLabel 'poisonVal
//                             orBool getKLabel(V) ==KLabel 'undef
    rule checkNsw(integerType(N:Int), I1:K, .ElemList) => .ElemList
    rule checkNsw(integerType(N:Int), I1:K, vectorValue(Es:ElemList))
            => vectorValue(checkNsw(integerType(N:Int), I1:K, Es:ElemList))
    rule checkNsw(integerType(N:Int), I1:K, elemCons(valValue(V:K), Es:ElemList))
            => elemCons(valValue(V), checkNsw(integerType(N:Int), I1:K, Es:ElemList))
         requires notBool isTheInt(V)

    rule checkNsw(integerType(N:Int), vectorValue(elemCons(valValue(I1:Int), Is1:ElemList))
                                                , elemCons(valValue(V:Int), Es:ElemList))
            => elemCons(valValue(poisonVal),
                   checkNsw(integerType(N:Int), vectorValue(elemCons(valValue(I1:Int), Is1:ElemList))
                 , Es:ElemList))
         requires I1 <Int (0 -Int (2 ^Int (N -Int 1))) orBool I1 >=Int (2 ^Int (N -Int 1))

    rule checkNsw(integerType(N:Int), vectorValue(elemCons(valValue(I1:Int), Is1:ElemList)), elemCons(valValue(V:Int), Es:ElemList))
            => elemCons(valValue(V), checkNsw(integerType(N:Int),
	       vectorValue(elemCons(valValue(I1:Int), Is1:ElemList)), Es:ElemList))
         requires I1 >=Int (0 -Int (2 ^Int (N -Int 1))) andBool I1 <Int (2 ^Int (N -Int 1))

    syntax Bool ::= isPowOfTwo(Int, Int)  [function]
    rule isPowOfTwo(A:Int, B:Int) => false
         requires A <Int B
    rule isPowOfTwo(A:Int, B:Int) => true
         requires A ==Int B
    rule isPowOfTwo(A:Int, B:Int) => isPowOfTwo(A, B *Int 2)
         requires A >Int B

    syntax KItem ::= getAlign(Set, K) [function]
    rule getAlign(.Set, .K) => alignEmpty
    rule getAlign(SetItem(K:K) S:Set, .K) => getAlign(S, K)
    rule getAlign(S:Set, align N:UnsignedInt) => String2Int(#tokenToString(N))
//    rule getAlign(S:Set, K:K => .K)
//         requires getKLabel(K) =/=KLabel 'align

    syntax ElemList ::= getOutEdges(K) [function]
    rule getOutEdges(I:IntType C:ConstValueRef,
              labelValue(V:ValueRef) Ju:JumpTable) => elemCons(val(addNameToString(V)),getOutEdges(Ju))
    rule getOutEdges(.JumpTable) => .ElemList
    rule getOutEdges(labelValue(V:ValueRef), Ju:LabelValues) => elemCon(val(addNameToString(V)),getOutEdges(Ju))
    rule getOutEdges(.LabelValues) => .ElemList
    rule getOutEdges(V:LocalName) => val(addNameToString(V))

    syntax ElemList ::= getArgsInFunction(ElemList) [function]
    rule getArgsInFunction(.ElemList) => .ElemList
    rule getArgsInFunction(elemCons(val(arg(S:Set, T:K, V:K)), E:ElemList))
            => elemCons(val(typeOperand(T, V)),getArgsInFunction(E))

    syntax Set ::= formArgSet(ElemList)      [function]
    rule formArgSet(.ElemList) => .Set
    rule formArgSet(elemCons(valValue(typeOperandResult(T:K, V:K)), E:ElemList))
            => SetItem(operand(T, V)) formArgSet(E)

endmodule
