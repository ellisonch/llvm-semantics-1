---
title: Progress Report 2 - MP2
author: Liyi Li (liyili2), Everett Hildenbrandt (hildenb2)
geometry: margin=2.5cm
format: latex
linestretch: 1.25
csl: ieee.csl
...


Project
=======

The goal is to create a directed-graph rewriting DSL in K which can be used to
specify compiler optimizations as CFG rewrites. We are using K because it would
be nice to immediately have a prototype executable of the rules, as well as
access to verification frameworks (like Isabelle and Coq). We would like to
extend this to data-dependence and call-graph optimizations as well eventually.

For reasoning about graph rewrites we are using CTL (computation tree logic).
CTL has an efficient proof system, and there has been previous work defining
optimizations using CTL[@ptrans-verif-opt].

CTL Specification
-----------------

We have defined and lightly tested the semantics of CTL in K. For testing we
have been hand-building graphs where we assign atomic predicates to each node in
the graph, then check if some specific CTL query returns true or false for that
graph. In a full-sized program the nodes of the graph will be generated by
instructions in the code, and the queries will be patterns that must be matched
for an optimization to fire. Note that these patterns include both CTL patterns
(language independent) and instruction patterns (language specific).

To integrate this with a language, we need to define the atomic predicates we
are interested in performing analysis over. This includes things like
`defines(V)` or `uses(V)` for `V` some variable. Given a specific variable, this
is an easy (though tedious) check by recursing into sub-formula on the language
we're optimizing over. Because we're not given specific variables and instead
are trying to find *which variables* will satisfy a given predicate at a given
instruction, this problem becomes harder.

One potential work-around is to do a pre-analysis to grab all the variables that
a specific program mentions, then check the predicates for each variable at each
node. It seems that the ideal solution would be to allow users to use the
concrete syntax of the language being optimized over, then we could use K's
builtin unification algorithms to decide if the instruction-level pattern
matches or not and simultaneously (if it does match) give us the variable
substitution. This would eliminate the need for us to do the pre-analysis, and
yields a sound and complete proof system (of matching logic).

LLVM Integration
----------------

Note that this project does not depend on the LLVM infrastructure (in fact we
are not using any of LLVM code or libraries for this, just the K-defined
semantics of LLVM). LLVM is a good target for this optimization technique
because it's already in CFG form, meaning that the K representation of LLVM is
already close to being in the form needed to analyze with CTL. It would have
been more feasible (for a semester time-scale) to focus on a smaller language.

Integration with the LLVM semantics is still underway. As mentioned above, this
will require many recursive definitions over the structure of the LLVM language
(which is quite a large language) to decide the atomic predicates.

Testing
-------

We have been using tests downloaded from the LLVM and gcc torture test suites.
We have tested the syntax of LLVM, and the LLVM semantics has been lightly
tested, though is still buggy. With the LLVM semantics defined, what we have is
an LLVM interpreter for free (by calling `krun`).

The CTL semantics have also been tested lightly on hand-crafted graphs. It
parses them fine (which is testing the CTL syntax), and can decide some queries
(testing the CTL semantics).

Integrating the LLVM and CTL semantics has proven difficult. This reflects poor
non-modular design choices in the initial CTL semantics. Recently we've fixed
some of these issues, but the overall result will be that the CTL semantics and
the LLVM semantics will be tied together a bit more than desirable. This is fine
for now, but eventually it would be nice to have a more generic CTL optimization
framework independent of LLVM.


References
==========

---
references:
-   id: ptrans-verif-opt
    author:
    -   family: Mansky
        given: William
    -   family: Griffith
        given: Dennis
    -   family: Gunter
        given: Elsa
    issued:
    -   year: '2014'
    title: Specifying and Executing Optimizations for Parallel Programs
    container-title: GRAPH Inspection and Traversal Engineering (GRAPHITE)
...
